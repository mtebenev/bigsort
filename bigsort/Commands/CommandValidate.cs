using System;
using System.ComponentModel.DataAnnotations;
using System.Data;
using System.IO;
using System.IO.Abstractions;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using BigSort.Common;
using BigSort.V2;
using BigSort.V2.Events;
using BigSort.Validation;
using Dapper;
using McMaster.Extensions.CommandLineUtils;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;

namespace BigSort.Commands
{
  /// <summary>
  /// The validation command.
  /// </summary>
  [Command(Name = "validate", Description = @"The command validates sorted files using sqlite database.
It reads the source file and puts the lines into a temporary sqlite database.
Then it reads the output file (generated by the merge-sort command) and compares it with content of the database.
Warning! This is slow command, for development purposes only.
")]
  internal class CommandValidate
  {
    [Required]
    [Argument(0, "Input file path")]
    public string InFilePath { get; set; }

    [Required]
    [Argument(1, "Output file path")]
    public string OutFilePath { get; set; }

    public async Task OnExecuteAsync()
    {

      var loggerFactory = LoggerFactory.Create(builder =>
      {
        builder
        .AddConsole()
        .SetMinimumLevel(LogLevel.Information);
      });
      var logger = loggerFactory.CreateLogger(nameof(CommandValidate));
      IDbConnection connection = null;

      try
      {
        var fileSystem = new FileSystem();
        var fsContextOptions = new FileContextOptions
        {
          InFilePath = this.InFilePath,
          UseOutFile = false
        };

        if(!fileSystem.File.Exists(this.OutFilePath))
        {
          throw new InvalidOperationException($"Could not open out file: {this.OutFilePath}");
        }

        using(var fileContext = new FileContext(fileSystem, loggerFactory, fsContextOptions))
        {
          logger.LogInformation($"Started validating {this.OutFilePath} against {fileContext.InFilePath}");

          const int pushBlockSize = 10000; // Will push lines in db by blocks of the size.
          var dbPath = fileContext.AddTempFile();
          connection = this.CreateDatabase(dbPath);
          var reader = new SourceReader();

          // Push records in db
          var context = new PipelineContext(loggerFactory, fileContext);
          var dbPusherBlock = DbPusherBlock.Create(loggerFactory, connection, fileContext.GetInFileSize());
          reader.Start(fileContext.InFilePath, pushBlockSize, context, dbPusherBlock);
          await dbPusherBlock.Completion;

          // Compare database with out file
          await this.CompareAsync(connection, context, this.OutFilePath);
          logger.LogInformation("The file is valid.");
        }
      }
      catch(Exception e)
      {
        logger.LogCritical(e, "The validation faulted");
      }
      finally
      {
        connection?.Close();
      }
    }

    /// <summary>
    /// Initializes the database.
    /// </summary>
    private IDbConnection CreateDatabase(string dbPath)
    {
      var connectionString = new SqliteConnectionStringBuilder
      {
        DataSource = dbPath,
      }.ToString();

      var connection = new SqliteConnection(connectionString);
      var queryTable = @"CREATE TABLE DataRecords (
                        DataNum   INTEGER        NOT NULL,
                        DataStr   NVARCHAR (256) NOT NULL
);";
      
      connection.Execute(queryTable);

      var queryIdx1 = "CREATE INDEX data_records_str_idx ON DataRecords (DataStr);";
      connection.Execute(queryIdx1);
      var queryIdx2 = "CREATE INDEX data_records_num_idx ON DataRecords (DataNum);";
      connection.Execute(queryIdx2);

      return connection;
    }

    /// <summary>
    /// Compares records in db with out file.
    /// </summary>
    private async Task CompareAsync(IDbConnection connection, IPipelineContext pipelineContext, string checkFilePath)
    {
      Console.WriteLine("Comparing out file against the sqlite database...");

      const int pageSize = 10000;
      var fileSize = new FileInfo(checkFilePath).Length;
      var joinBlock = new JoinBlock<DataRecord[], BufferReadEvent>();

      // Compare the records.
      var comparisonBlock = ComparisonBlock.Create(pipelineContext.LoggerFactory, fileSize);
      joinBlock.LinkTo(comparisonBlock, new DataflowLinkOptions { PropagateCompletion = true });

      // Read db records
      var dbLoaderTask = DbDataLoader.StartAsync(connection, pageSize, joinBlock.Target1);

      // Read the file
      var sourceReader = new SourceReader();
      var readerTask = sourceReader.StartAsync(checkFilePath, pageSize, pipelineContext, joinBlock.Target2);

      await comparisonBlock.Completion;
      await Task.WhenAll(readerTask, dbLoaderTask);
    }
  }
}
